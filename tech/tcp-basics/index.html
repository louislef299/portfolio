<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>TCP/IP Basics | Louis Lefebvre</title>
<meta name=title content="TCP/IP Basics"><meta name=description content="Just going over the TCP/IP basics here to build out a good foundation as I
continue my bluetooth journey. It never hurts to go over the basics, especially
since there are so many tools and libraries that try to simplify that process
for programmers.
TCP Basics
A TCP server requires the following steps:

Listen for Incoming Connections
Accept Incoming Connections
Handle Client Connections
Read and Write Data
Close the Connection

The client will:"><meta name=author content><meta name=keywords content><meta property="og:url" content="https://louislefebvre.net/tech/tcp-basics/"><meta property="og:site_name" content="Louis Lefebvre"><meta property="og:title" content="TCP/IP Basics"><meta property="og:description" content="Just going over the TCP/IP basics here to build out a good foundation as I continue my bluetooth journey. It never hurts to go over the basics, especially since there are so many tools and libraries that try to simplify that process for programmers.
TCP Basics A TCP server requires the following steps:
Listen for Incoming Connections Accept Incoming Connections Handle Client Connections Read and Write Data Close the Connection The client will:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="tech"><meta property="article:published_time" content="2024-12-26T13:18:58-06:00"><meta property="article:modified_time" content="2024-12-26T13:18:58-06:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TCP/IP Basics"><meta name=twitter:description content="Just going over the TCP/IP basics here to build out a good foundation as I continue my bluetooth journey. It never hurts to go over the basics, especially since there are so many tools and libraries that try to simplify that process for programmers.
TCP Basics A TCP server requires the following steps:
Listen for Incoming Connections Accept Incoming Connections Handle Client Connections Read and Write Data Close the Connection The client will:"><meta itemprop=name content="TCP/IP Basics"><meta itemprop=description content="Just going over the TCP/IP basics here to build out a good foundation as I continue my bluetooth journey. It never hurts to go over the basics, especially since there are so many tools and libraries that try to simplify that process for programmers.
TCP Basics A TCP server requires the following steps:
Listen for Incoming Connections Accept Incoming Connections Handle Client Connections Read and Write Data Close the Connection The client will:"><meta itemprop=datePublished content="2024-12-26T13:18:58-06:00"><meta itemprop=dateModified content="2024-12-26T13:18:58-06:00"><meta itemprop=wordCount content="686"><meta name=referrer content="no-referrer-when-downgrade"><link href=/original.min.css rel=stylesheet><script src=/js/d3.v3.min.js></script><script src=/js/topojson.v1.min.js></script><script src=/js/datamaps.world.min.js></script></head><body><header><a class=skip-link href=#main-content>Skip to main content</a>
<a href=/ class=title><h1>Louis Lefebvre</h1></a><nav><a href=/tech/>Tech</a>
<a href=/travel/>Travel</a></nav></header><main id=main-content><h1>TCP/IP Basics</h1><p class=byline><time datetime=2024-12-26 pubdate>2024-12-26</time></p><content><p>Just going over the <a href=https://okanexe.medium.com/the-complete-guide-to-tcp-ip-connections-in-golang-1216dae27b5a>TCP/IP basics</a> here to build out a good foundation as I
continue my bluetooth journey. It never hurts to go over the basics, especially
since there are so many tools and libraries that try to simplify that process
for programmers.</p><h2 id=tcp-basics>TCP Basics</h2><p>A TCP server requires the following steps:</p><ol><li>Listen for Incoming Connections</li><li>Accept Incoming Connections</li><li>Handle Client Connections</li><li>Read and Write Data</li><li>Close the Connection</li></ol><p>The client will:</p><ol><li>Dial the Server</li><li>Read and Write Data</li><li>Close the Connection</li></ol><h2 id=implementation-in-go>Implementation in Go</h2><h3 id=tcp-server>TCP Server</h3><p>Creating the server is a <a href="https://www.google.com/search?client=firefox-b-1-d&amp;q=how+to+create+a+simple+tcp+server+in+go">simple google search</a>, and after a
bit of consideration and fooling around, this was the final connection handler
that I settled on:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleClient</span>(<span style=color:#a6e22e>conn</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Conn</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eof</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a buffer to read data into
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read data from the client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>buffer</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>eof</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;could not read from client connection:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Process and use the data (here, we&#39;ll just print it)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;buffer received: %s\n&#34;</span>, <span style=color:#a6e22e>buffer</span>[:<span style=color:#a6e22e>n</span>])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>eof</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;EOF reached&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=tcp-client>TCP Client</h3><p>The client was super simple and just initiated the connection to
<code>localhost:8080</code>, wrote <code>Hello, Server!</code> and then closed the connection. Pretty
simple.</p><h3 id=building-the-dockerfile>Building the Dockerfile</h3><p>This was where I had a lot of fun experimenting. In order to understand why I
created the Dockerfile the way I did, it helps to understand I created a
directory under an existing project, so my <code>go.mod</code> and <code>go.sum</code> files were
under the parent of the project while my Go files were under the directory
structure I had created, which looked like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── go.mod
</span></span><span style=display:flex><span>├── go.sum
</span></span><span style=display:flex><span>├── Makefile
</span></span><span style=display:flex><span>tcp/
</span></span><span style=display:flex><span>├── client
</span></span><span style=display:flex><span>│   └── main.go
</span></span><span style=display:flex><span>├── Dockerfile
</span></span><span style=display:flex><span>└── server
</span></span><span style=display:flex><span>    └── main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> directories, <span style=color:#ae81ff>3</span> files</span></span></code></pre></div><p>The Dockerfile itself is variabilized so that I can build the client or server
using the same container template(DRY):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># syntax=docker/dockerfile:1</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># check=error=true</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.23.4-alpine3.21</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /usr/src/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># pre-copy/cache go.mod for pre-downloading dependencies and only redownloading</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># them in subsequent builds if they change</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> go.mod go.sum ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go mod download <span style=color:#f92672>&amp;&amp;</span> go mod verify<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> TCP_TARGET<span style=color:#f92672>=</span>server
</span></span><span style=display:flex><span><span style=color:#66d9ef>COPY</span> ./tcp/$TCP_TARGET .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go build -v -o /usr/local/bin/app ./...<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 8080</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;app&#34;</span>]</span></span></code></pre></div><p>Using the <code>TCP_TARGET</code> ARG helps change the <code>--build-arg</code> to <code>client</code> if I would
want to build that go binary for whatever reason. Otherwise, it just defaults to
<code>server</code>.</p><p>One thing to note, is I take advantage of the <a href=https://docs.docker.com/reference/dockerfile/#check>Docker check directive</a> to
validate proper use of the Dockerfile. It proved useful while I was writing up
the Dockerfile and had misplaced the <code>TCP_TARGET</code> and got the following warning
message:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ae81ff>1</span> warning found <span style=color:#f92672>(</span>use docker --debug to expand<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span> - UndefinedVar: Usage of undefined variable <span style=color:#e6db74>&#39;$TCP_TARGET&#39;</span> <span style=color:#f92672>(</span>line 13<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Dockerfile:1
</span></span><span style=display:flex><span>--------------------
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span> | &gt;&gt;&gt; <span style=color:#75715e># syntax=docker/dockerfile:1</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>2</span> |     <span style=color:#75715e># check=error=true</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>3</span> |     ARG TCP_TARGET<span style=color:#f92672>=</span>server
</span></span><span style=display:flex><span>--------------------
</span></span><span style=display:flex><span>ERROR: failed to solve: lint violation found <span style=color:#66d9ef>for</span> rules: UndefinedVar
</span></span><span style=display:flex><span>make: *** <span style=color:#f92672>[</span>Makefile:7: build<span style=color:#f92672>]</span> Error <span style=color:#ae81ff>1</span></span></span></code></pre></div><p>This is helpful for local development as well as CI/CD to make sure other
developers who may not be as familiar with Dockerfiles aren&rsquo;t messing with
potentially for complex configurations.</p><p>In order to simplify the container build process and reduce configuration
errors, I also put together a quick Makefile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>DEFAULT_GOAL <span style=color:#f92672>?=</span> default
</span></span><span style=display:flex><span>TARGET <span style=color:#f92672>?=</span> server
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>default</span><span style=color:#f92672>:</span> build run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>build</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    docker build --build-arg TCP_TARGET<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>TARGET<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>        -t tcp-<span style=color:#e6db74>${</span>TARGET<span style=color:#e6db74>}</span> -f ./tcp/Dockerfile .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>run</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    docker run --rm --name <span style=color:#e6db74>${</span>TARGET<span style=color:#e6db74>}</span> --network host -d tcp-<span style=color:#e6db74>${</span>TARGET<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>clean</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    docker kill <span style=color:#e6db74>${</span>TARGET<span style=color:#e6db74>}</span>
</span></span></code></pre></div><p>One problem that I had was the TCP server not seeming to receive the client
message when ran in the Docker network, but when run locally, it seemed to work
fine. Since this was just a little thing to mess around with, I decided to just
let it go and run the container with the <code>--network host</code> option. Maybe I&rsquo;ll
come back around to it?</p><h2 id=conclusion>Conclusion</h2><p>This was just a simple run-through of running a TCP server in Go and then
containerizing that server. It seems like a simple, silly project, but this
should help me get warmed up for my next experiment, <a href=https://louislefebvre.net/tech/containerized-bluetooth/>containerizing a bluetooth
application</a>.</p></content><p></p><p><a href='mailto:louislefebvre1999@gmail.com?subject=Reply%20to%20"TCP%2fIP%20Basics"'>Reply to this post by email ↪</a></p></main><footer><small>2023 Louis LeFebvre | Made With ❤️ and <a href=https://clente.github.io/hugo-bearcub/>ᕦʕ •ᴥ•ʔᕤ</a></small></footer></body></html>